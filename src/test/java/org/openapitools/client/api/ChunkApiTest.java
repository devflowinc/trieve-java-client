/*
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.ChunkMetadata;
import org.openapitools.client.model.ChunkMetadataWithFileData;
import org.openapitools.client.model.CreateChunkData;
import org.openapitools.client.model.ErrorResponseBody;
import org.openapitools.client.model.GenerateChunksRequest;
import org.openapitools.client.model.RecommendChunksRequest;
import org.openapitools.client.model.ReturnQueuedChunk;
import org.openapitools.client.model.SearchChunkData;
import org.openapitools.client.model.SearchChunkQueryResponseBody;
import org.openapitools.client.model.SuggestedQueriesRequest;
import org.openapitools.client.model.SuggestedQueriesResponse;
import java.util.UUID;
import org.openapitools.client.model.UpdateChunkByTrackingIdData;
import org.openapitools.client.model.UpdateChunkData;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for ChunkApi
 */
@Disabled
public class ChunkApiTest {

    private final ChunkApi api = new ChunkApi();

    /**
     * Create or Upsert Chunk or Chunks
     *
     * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createChunkTest() throws ApiException {
        String trDataset = null;
        CreateChunkData createChunkData = null;
        ReturnQueuedChunk response = api.createChunk(trDataset, createChunkData);
        // TODO: test validations
    }

    /**
     * Generate suggested queries
     *
     * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createSuggestedQueriesHandlerTest() throws ApiException {
        String trDataset = null;
        SuggestedQueriesRequest suggestedQueriesRequest = null;
        SuggestedQueriesResponse response = api.createSuggestedQueriesHandler(trDataset, suggestedQueriesRequest);
        // TODO: test validations
    }

    /**
     * Delete Chunk
     *
     * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteChunkTest() throws ApiException {
        String trDataset = null;
        UUID chunkId = null;
        api.deleteChunk(trDataset, chunkId);
        // TODO: test validations
    }

    /**
     * Delete Chunk By Tracking Id
     *
     * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteChunkByTrackingIdTest() throws ApiException {
        String trDataset = null;
        String trackingId = null;
        api.deleteChunkByTrackingId(trDataset, trackingId);
        // TODO: test validations
    }

    /**
     * RAG on Specified Chunks
     *
     * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \&quot;search before generate\&quot; page at docs.trieve.ai.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void generateOffChunksTest() throws ApiException {
        String trDataset = null;
        GenerateChunksRequest generateChunksRequest = null;
        String response = api.generateOffChunks(trDataset, generateChunksRequest);
        // TODO: test validations
    }

    /**
     * Get Chunk By Id
     *
     * Get Chunk By Id  Get a singular chunk by id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getChunkByIdTest() throws ApiException {
        String trDataset = null;
        UUID chunkId = null;
        ChunkMetadata response = api.getChunkById(trDataset, chunkId);
        // TODO: test validations
    }

    /**
     * Get Chunk By Tracking Id
     *
     * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getChunkByTrackingIdTest() throws ApiException {
        String trDataset = null;
        String trackingId = null;
        ChunkMetadata response = api.getChunkByTrackingId(trDataset, trackingId);
        // TODO: test validations
    }

    /**
     * Get Recommended Chunks
     *
     * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \&quot;add to playlist\&quot; recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getRecommendedChunksTest() throws ApiException {
        String trDataset = null;
        RecommendChunksRequest recommendChunksRequest = null;
        List<ChunkMetadataWithFileData> response = api.getRecommendedChunks(trDataset, recommendChunksRequest);
        // TODO: test validations
    }

    /**
     * Search
     *
     * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results&#39; &#x60;chunk_html&#x60; values will be modified with &#x60;&lt;b&gt;&#x60; tags for sub-sentence highlighting.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void searchChunkTest() throws ApiException {
        String trDataset = null;
        SearchChunkData searchChunkData = null;
        SearchChunkQueryResponseBody response = api.searchChunk(trDataset, searchChunkData);
        // TODO: test validations
    }

    /**
     * Update Chunk
     *
     * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateChunkTest() throws ApiException {
        String trDataset = null;
        UpdateChunkData updateChunkData = null;
        api.updateChunk(trDataset, updateChunkData);
        // TODO: test validations
    }

    /**
     * Update Chunk By Tracking Id
     *
     * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateChunkByTrackingIdTest() throws ApiException {
        String trDataset = null;
        UpdateChunkByTrackingIdData updateChunkByTrackingIdData = null;
        api.updateChunkByTrackingId(trDataset, updateChunkByTrackingIdData);
        // TODO: test validations
    }

}

/*
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import javax.validation.constraints.*;
import javax.validation.Valid;

import org.openapitools.client.model.CreateMessageData;
import org.openapitools.client.model.EditMessageData;
import org.openapitools.client.model.ErrorResponseBody;
import org.openapitools.client.model.Message;
import org.openapitools.client.model.RegenerateMessageData;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MessageApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MessageApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MessageApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createMessageCompletionHandler
     * @param trDataset The dataset id to use for the request (required)
     * @param createMessageData JSON request payload to create a message completion (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createMessageCompletionHandlerCall(String trDataset, CreateMessageData createMessageData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createMessageData;

        // create path and map variables
        String localVarPath = "/api/message";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createMessageCompletionHandlerValidateBeforeCall(String trDataset, CreateMessageData createMessageData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling createMessageCompletionHandler(Async)");
        }

        // verify the required parameter 'createMessageData' is set
        if (createMessageData == null) {
            throw new ApiException("Missing the required parameter 'createMessageData' when calling createMessageCompletionHandler(Async)");
        }

        return createMessageCompletionHandlerCall(trDataset, createMessageData, _callback);

    }

    /**
     * Create a message
     * Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param createMessageData JSON request payload to create a message completion (required)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public String createMessageCompletionHandler(String trDataset, CreateMessageData createMessageData) throws ApiException {
        ApiResponse<String> localVarResp = createMessageCompletionHandlerWithHttpInfo(trDataset, createMessageData);
        return localVarResp.getData();
    }

    /**
     * Create a message
     * Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param createMessageData JSON request payload to create a message completion (required)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> createMessageCompletionHandlerWithHttpInfo( @NotNull String trDataset,  @NotNull CreateMessageData createMessageData) throws ApiException {
        okhttp3.Call localVarCall = createMessageCompletionHandlerValidateBeforeCall(trDataset, createMessageData, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a message (asynchronously)
     * Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param createMessageData JSON request payload to create a message completion (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createMessageCompletionHandlerAsync(String trDataset, CreateMessageData createMessageData, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = createMessageCompletionHandlerValidateBeforeCall(trDataset, createMessageData, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for editMessageHandler
     * @param trDataset The dataset id to use for the request (required)
     * @param editMessageData JSON request payload to edit a message and get a new stream (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a HTTP stream, check the chat or search UI for an example how to process this </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call editMessageHandlerCall(String trDataset, EditMessageData editMessageData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = editMessageData;

        // create path and map variables
        String localVarPath = "/api/message";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call editMessageHandlerValidateBeforeCall(String trDataset, EditMessageData editMessageData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling editMessageHandler(Async)");
        }

        // verify the required parameter 'editMessageData' is set
        if (editMessageData == null) {
            throw new ApiException("Missing the required parameter 'editMessageData' when calling editMessageHandler(Async)");
        }

        return editMessageHandlerCall(trDataset, editMessageData, _callback);

    }

    /**
     * Edit a message
     * Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param editMessageData JSON request payload to edit a message and get a new stream (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a HTTP stream, check the chat or search UI for an example how to process this </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public void editMessageHandler(String trDataset, EditMessageData editMessageData) throws ApiException {
        editMessageHandlerWithHttpInfo(trDataset, editMessageData);
    }

    /**
     * Edit a message
     * Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param editMessageData JSON request payload to edit a message and get a new stream (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a HTTP stream, check the chat or search UI for an example how to process this </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> editMessageHandlerWithHttpInfo( @NotNull String trDataset,  @NotNull EditMessageData editMessageData) throws ApiException {
        okhttp3.Call localVarCall = editMessageHandlerValidateBeforeCall(trDataset, editMessageData, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Edit a message (asynchronously)
     * Edit a message  Edit a message which exists within the topic&#39;s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param editMessageData JSON request payload to edit a message and get a new stream (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a HTTP stream, check the chat or search UI for an example how to process this </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call editMessageHandlerAsync(String trDataset, EditMessageData editMessageData, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = editMessageHandlerValidateBeforeCall(trDataset, editMessageData, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAllTopicMessages
     * @param trDataset The dataset id to use for the request (required)
     * @param messagesTopicId The ID of the topic to get messages for. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All messages relating to the topic with the given ID </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the messages </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAllTopicMessagesCall(String trDataset, UUID messagesTopicId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/messages/{messages_topic_id}"
            .replace("{" + "messages_topic_id" + "}", localVarApiClient.escapeString(messagesTopicId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAllTopicMessagesValidateBeforeCall(String trDataset, UUID messagesTopicId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getAllTopicMessages(Async)");
        }

        // verify the required parameter 'messagesTopicId' is set
        if (messagesTopicId == null) {
            throw new ApiException("Missing the required parameter 'messagesTopicId' when calling getAllTopicMessages(Async)");
        }

        return getAllTopicMessagesCall(trDataset, messagesTopicId, _callback);

    }

    /**
     * Get all messages for a given topic
     * Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param messagesTopicId The ID of the topic to get messages for. (required)
     * @return List&lt;Message&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All messages relating to the topic with the given ID </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the messages </td><td>  -  </td></tr>
     </table>
     */
    public List<Message> getAllTopicMessages(String trDataset, UUID messagesTopicId) throws ApiException {
        ApiResponse<List<Message>> localVarResp = getAllTopicMessagesWithHttpInfo(trDataset, messagesTopicId);
        return localVarResp.getData();
    }

    /**
     * Get all messages for a given topic
     * Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param messagesTopicId The ID of the topic to get messages for. (required)
     * @return ApiResponse&lt;List&lt;Message&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All messages relating to the topic with the given ID </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the messages </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Message>> getAllTopicMessagesWithHttpInfo( @NotNull String trDataset,  @NotNull UUID messagesTopicId) throws ApiException {
        okhttp3.Call localVarCall = getAllTopicMessagesValidateBeforeCall(trDataset, messagesTopicId, null);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get all messages for a given topic (asynchronously)
     * Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param messagesTopicId The ID of the topic to get messages for. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All messages relating to the topic with the given ID </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the messages </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAllTopicMessagesAsync(String trDataset, UUID messagesTopicId, final ApiCallback<List<Message>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAllTopicMessagesValidateBeforeCall(trDataset, messagesTopicId, _callback);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for regenerateMessageHandler
     * @param trDataset The dataset id to use for the request (required)
     * @param regenerateMessageData JSON request payload to delete an agent message then regenerate it in a strem (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call regenerateMessageHandlerCall(String trDataset, RegenerateMessageData regenerateMessageData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = regenerateMessageData;

        // create path and map variables
        String localVarPath = "/api/message";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call regenerateMessageHandlerValidateBeforeCall(String trDataset, RegenerateMessageData regenerateMessageData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling regenerateMessageHandler(Async)");
        }

        // verify the required parameter 'regenerateMessageData' is set
        if (regenerateMessageData == null) {
            throw new ApiException("Missing the required parameter 'regenerateMessageData' when calling regenerateMessageHandler(Async)");
        }

        return regenerateMessageHandlerCall(trDataset, regenerateMessageData, _callback);

    }

    /**
     * Regenerate message
     * Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param regenerateMessageData JSON request payload to delete an agent message then regenerate it in a strem (required)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public String regenerateMessageHandler(String trDataset, RegenerateMessageData regenerateMessageData) throws ApiException {
        ApiResponse<String> localVarResp = regenerateMessageHandlerWithHttpInfo(trDataset, regenerateMessageData);
        return localVarResp.getData();
    }

    /**
     * Regenerate message
     * Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param regenerateMessageData JSON request payload to delete an agent message then regenerate it in a strem (required)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> regenerateMessageHandlerWithHttpInfo( @NotNull String trDataset,  @NotNull RegenerateMessageData regenerateMessageData) throws ApiException {
        okhttp3.Call localVarCall = regenerateMessageHandlerValidateBeforeCall(trDataset, regenerateMessageData, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Regenerate message (asynchronously)
     * Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like &#x60;[chunks]||mesage&#x60;. See docs.trieve.ai for more information.
     * @param trDataset The dataset id to use for the request (required)
     * @param regenerateMessageData JSON request payload to delete an agent message then regenerate it in a strem (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting a chat completion </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call regenerateMessageHandlerAsync(String trDataset, RegenerateMessageData regenerateMessageData, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = regenerateMessageHandlerValidateBeforeCall(trDataset, regenerateMessageData, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}

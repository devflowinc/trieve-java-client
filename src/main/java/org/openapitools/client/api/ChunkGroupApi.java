/*
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import javax.validation.constraints.*;
import javax.validation.Valid;

import org.openapitools.client.model.AddChunkToGroupData;
import org.openapitools.client.model.BookmarkData;
import org.openapitools.client.model.BookmarkGroupResult;
import org.openapitools.client.model.ChunkGroup;
import org.openapitools.client.model.CreateChunkGroupData;
import org.openapitools.client.model.ErrorResponseBody;
import org.openapitools.client.model.GetGroupsForChunksData;
import org.openapitools.client.model.GroupData;
import org.openapitools.client.model.GroupScoreChunkDTO;
import org.openapitools.client.model.ReccomendGroupChunksRequest;
import org.openapitools.client.model.SearchGroupsResult;
import org.openapitools.client.model.SearchOverGroupsData;
import org.openapitools.client.model.SearchOverGroupsResponseBody;
import org.openapitools.client.model.SearchWithinGroupData;
import java.util.UUID;
import org.openapitools.client.model.UpdateChunkGroupData;
import org.openapitools.client.model.UpdateGroupByTrackingIDData;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ChunkGroupApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ChunkGroupApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ChunkGroupApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for addChunkToGroup
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group to add the chunk to as a bookmark (required)
     * @param addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was added to the group (bookmark&#39;ed). </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addChunkToGroupCall(String trDataset, UUID groupId, AddChunkToGroupData addChunkToGroupData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = addChunkToGroupData;

        // create path and map variables
        String localVarPath = "/api/chunk_group/chunk/{group_id}"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call addChunkToGroupValidateBeforeCall(String trDataset, UUID groupId, AddChunkToGroupData addChunkToGroupData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling addChunkToGroup(Async)");
        }

        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling addChunkToGroup(Async)");
        }

        // verify the required parameter 'addChunkToGroupData' is set
        if (addChunkToGroupData == null) {
            throw new ApiException("Missing the required parameter 'addChunkToGroupData' when calling addChunkToGroup(Async)");
        }

        return addChunkToGroupCall(trDataset, groupId, addChunkToGroupData, _callback);

    }

    /**
     * Add Chunk to Group
     * Add Chunk to Group  Route to add a chunk to a group.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group to add the chunk to as a bookmark (required)
     * @param addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it) (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was added to the group (bookmark&#39;ed). </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in. </td><td>  -  </td></tr>
     </table>
     */
    public void addChunkToGroup(String trDataset, UUID groupId, AddChunkToGroupData addChunkToGroupData) throws ApiException {
        addChunkToGroupWithHttpInfo(trDataset, groupId, addChunkToGroupData);
    }

    /**
     * Add Chunk to Group
     * Add Chunk to Group  Route to add a chunk to a group.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group to add the chunk to as a bookmark (required)
     * @param addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it) (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was added to the group (bookmark&#39;ed). </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> addChunkToGroupWithHttpInfo( @NotNull String trDataset,  @NotNull UUID groupId,  @NotNull AddChunkToGroupData addChunkToGroupData) throws ApiException {
        okhttp3.Call localVarCall = addChunkToGroupValidateBeforeCall(trDataset, groupId, addChunkToGroupData, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Add Chunk to Group (asynchronously)
     * Add Chunk to Group  Route to add a chunk to a group.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group to add the chunk to as a bookmark (required)
     * @param addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was added to the group (bookmark&#39;ed). </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addChunkToGroupAsync(String trDataset, UUID groupId, AddChunkToGroupData addChunkToGroupData, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = addChunkToGroupValidateBeforeCall(trDataset, groupId, addChunkToGroupData, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for addChunkToGroupByTrackingId
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Id of the group to add the chunk to as a bookmark (required)
     * @param addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was added to the group (bookmark&#39;ed). </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addChunkToGroupByTrackingIdCall(String trDataset, String trackingId, AddChunkToGroupData addChunkToGroupData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = addChunkToGroupData;

        // create path and map variables
        String localVarPath = "/api/chunk_group/tracking_id/{tracking_id}"
            .replace("{" + "tracking_id" + "}", localVarApiClient.escapeString(trackingId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call addChunkToGroupByTrackingIdValidateBeforeCall(String trDataset, String trackingId, AddChunkToGroupData addChunkToGroupData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling addChunkToGroupByTrackingId(Async)");
        }

        // verify the required parameter 'trackingId' is set
        if (trackingId == null) {
            throw new ApiException("Missing the required parameter 'trackingId' when calling addChunkToGroupByTrackingId(Async)");
        }

        // verify the required parameter 'addChunkToGroupData' is set
        if (addChunkToGroupData == null) {
            throw new ApiException("Missing the required parameter 'addChunkToGroupData' when calling addChunkToGroupByTrackingId(Async)");
        }

        return addChunkToGroupByTrackingIdCall(trDataset, trackingId, addChunkToGroupData, _callback);

    }

    /**
     * Add Chunk to Group by Tracking ID
     * Add Chunk to Group by Tracking ID  Route to add a chunk to a group by tracking id.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Id of the group to add the chunk to as a bookmark (required)
     * @param addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it) (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was added to the group (bookmark&#39;ed). </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in. </td><td>  -  </td></tr>
     </table>
     */
    public void addChunkToGroupByTrackingId(String trDataset, String trackingId, AddChunkToGroupData addChunkToGroupData) throws ApiException {
        addChunkToGroupByTrackingIdWithHttpInfo(trDataset, trackingId, addChunkToGroupData);
    }

    /**
     * Add Chunk to Group by Tracking ID
     * Add Chunk to Group by Tracking ID  Route to add a chunk to a group by tracking id.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Id of the group to add the chunk to as a bookmark (required)
     * @param addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it) (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was added to the group (bookmark&#39;ed). </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> addChunkToGroupByTrackingIdWithHttpInfo( @NotNull String trDataset,  @NotNull String trackingId,  @NotNull AddChunkToGroupData addChunkToGroupData) throws ApiException {
        okhttp3.Call localVarCall = addChunkToGroupByTrackingIdValidateBeforeCall(trDataset, trackingId, addChunkToGroupData, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Add Chunk to Group by Tracking ID (asynchronously)
     * Add Chunk to Group by Tracking ID  Route to add a chunk to a group by tracking id.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Id of the group to add the chunk to as a bookmark (required)
     * @param addChunkToGroupData JSON request payload to add a chunk to a group (bookmark it) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was added to the group (bookmark&#39;ed). </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addChunkToGroupByTrackingIdAsync(String trDataset, String trackingId, AddChunkToGroupData addChunkToGroupData, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = addChunkToGroupByTrackingIdValidateBeforeCall(trDataset, trackingId, addChunkToGroupData, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for createChunkGroup
     * @param trDataset The dataset id to use for the request (required)
     * @param createChunkGroupData JSON request payload to cretea a chunkGroup (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the created chunkGroup </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to creating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createChunkGroupCall(String trDataset, CreateChunkGroupData createChunkGroupData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createChunkGroupData;

        // create path and map variables
        String localVarPath = "/api/chunk_group";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createChunkGroupValidateBeforeCall(String trDataset, CreateChunkGroupData createChunkGroupData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling createChunkGroup(Async)");
        }

        // verify the required parameter 'createChunkGroupData' is set
        if (createChunkGroupData == null) {
            throw new ApiException("Missing the required parameter 'createChunkGroupData' when calling createChunkGroup(Async)");
        }

        return createChunkGroupCall(trDataset, createChunkGroupData, _callback);

    }

    /**
     * Create Chunk Group
     * Create Chunk Group  Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail.
     * @param trDataset The dataset id to use for the request (required)
     * @param createChunkGroupData JSON request payload to cretea a chunkGroup (required)
     * @return ChunkGroup
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the created chunkGroup </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to creating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public ChunkGroup createChunkGroup(String trDataset, CreateChunkGroupData createChunkGroupData) throws ApiException {
        ApiResponse<ChunkGroup> localVarResp = createChunkGroupWithHttpInfo(trDataset, createChunkGroupData);
        return localVarResp.getData();
    }

    /**
     * Create Chunk Group
     * Create Chunk Group  Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail.
     * @param trDataset The dataset id to use for the request (required)
     * @param createChunkGroupData JSON request payload to cretea a chunkGroup (required)
     * @return ApiResponse&lt;ChunkGroup&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the created chunkGroup </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to creating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ChunkGroup> createChunkGroupWithHttpInfo( @NotNull String trDataset,  @NotNull CreateChunkGroupData createChunkGroupData) throws ApiException {
        okhttp3.Call localVarCall = createChunkGroupValidateBeforeCall(trDataset, createChunkGroupData, null);
        Type localVarReturnType = new TypeToken<ChunkGroup>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Chunk Group (asynchronously)
     * Create Chunk Group  Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail.
     * @param trDataset The dataset id to use for the request (required)
     * @param createChunkGroupData JSON request payload to cretea a chunkGroup (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the created chunkGroup </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to creating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createChunkGroupAsync(String trDataset, CreateChunkGroupData createChunkGroupData, final ApiCallback<ChunkGroup> _callback) throws ApiException {

        okhttp3.Call localVarCall = createChunkGroupValidateBeforeCall(trDataset, createChunkGroupData, _callback);
        Type localVarReturnType = new TypeToken<ChunkGroup>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteChunkGroup
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param deleteChunks Delete the chunks within the group (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to deleting the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteChunkGroupCall(String trDataset, UUID groupId, Boolean deleteChunks, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk_group/{group_id}"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deleteChunks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("delete_chunks", deleteChunks));
        }

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteChunkGroupValidateBeforeCall(String trDataset, UUID groupId, Boolean deleteChunks, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling deleteChunkGroup(Async)");
        }

        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling deleteChunkGroup(Async)");
        }

        // verify the required parameter 'deleteChunks' is set
        if (deleteChunks == null) {
            throw new ApiException("Missing the required parameter 'deleteChunks' when calling deleteChunkGroup(Async)");
        }

        return deleteChunkGroupCall(trDataset, groupId, deleteChunks, _callback);

    }

    /**
     * Delete Group
     * Delete Group  This will delete a chunk_group. This will not delete the chunks that are in the group. We will soon support deleting a chunk_group along with its member chunks.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param deleteChunks Delete the chunks within the group (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to deleting the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public void deleteChunkGroup(String trDataset, UUID groupId, Boolean deleteChunks) throws ApiException {
        deleteChunkGroupWithHttpInfo(trDataset, groupId, deleteChunks);
    }

    /**
     * Delete Group
     * Delete Group  This will delete a chunk_group. This will not delete the chunks that are in the group. We will soon support deleting a chunk_group along with its member chunks.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param deleteChunks Delete the chunks within the group (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to deleting the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteChunkGroupWithHttpInfo( @NotNull String trDataset,  @NotNull UUID groupId,  @NotNull Boolean deleteChunks) throws ApiException {
        okhttp3.Call localVarCall = deleteChunkGroupValidateBeforeCall(trDataset, groupId, deleteChunks, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Group (asynchronously)
     * Delete Group  This will delete a chunk_group. This will not delete the chunks that are in the group. We will soon support deleting a chunk_group along with its member chunks.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param deleteChunks Delete the chunks within the group (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to deleting the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteChunkGroupAsync(String trDataset, UUID groupId, Boolean deleteChunks, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteChunkGroupValidateBeforeCall(trDataset, groupId, deleteChunks, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteGroupByTrackingId
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Tracking id of the chunk_group to delete (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to deleting the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteGroupByTrackingIdCall(String trDataset, String trackingId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk_group/tracking_id/{tracking_id}"
            .replace("{" + "tracking_id" + "}", localVarApiClient.escapeString(trackingId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteGroupByTrackingIdValidateBeforeCall(String trDataset, String trackingId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling deleteGroupByTrackingId(Async)");
        }

        // verify the required parameter 'trackingId' is set
        if (trackingId == null) {
            throw new ApiException("Missing the required parameter 'trackingId' when calling deleteGroupByTrackingId(Async)");
        }

        return deleteGroupByTrackingIdCall(trDataset, trackingId, _callback);

    }

    /**
     * Delete Group by Tracking ID
     * Delete Group by Tracking ID  Delete a chunk_group with the given tracking id.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Tracking id of the chunk_group to delete (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to deleting the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public void deleteGroupByTrackingId(String trDataset, String trackingId) throws ApiException {
        deleteGroupByTrackingIdWithHttpInfo(trDataset, trackingId);
    }

    /**
     * Delete Group by Tracking ID
     * Delete Group by Tracking ID  Delete a chunk_group with the given tracking id.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Tracking id of the chunk_group to delete (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to deleting the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteGroupByTrackingIdWithHttpInfo( @NotNull String trDataset,  @NotNull String trackingId) throws ApiException {
        okhttp3.Call localVarCall = deleteGroupByTrackingIdValidateBeforeCall(trDataset, trackingId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Group by Tracking ID (asynchronously)
     * Delete Group by Tracking ID  Delete a chunk_group with the given tracking id.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Tracking id of the chunk_group to delete (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to deleting the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteGroupByTrackingIdAsync(String trDataset, String trackingId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteGroupByTrackingIdValidateBeforeCall(trDataset, trackingId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getChunkGroup
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the group with the given tracking id </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the group with the given tracking id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunkGroupCall(String trDataset, UUID groupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk_group/{group_id}"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChunkGroupValidateBeforeCall(String trDataset, UUID groupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getChunkGroup(Async)");
        }

        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling getChunkGroup(Async)");
        }

        return getChunkGroupCall(trDataset, groupId, _callback);

    }

    /**
     * Get Group
     * Get Group  Fetch the group with the given id. get_group
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @return ChunkGroup
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the group with the given tracking id </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the group with the given tracking id </td><td>  -  </td></tr>
     </table>
     */
    public ChunkGroup getChunkGroup(String trDataset, UUID groupId) throws ApiException {
        ApiResponse<ChunkGroup> localVarResp = getChunkGroupWithHttpInfo(trDataset, groupId);
        return localVarResp.getData();
    }

    /**
     * Get Group
     * Get Group  Fetch the group with the given id. get_group
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @return ApiResponse&lt;ChunkGroup&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the group with the given tracking id </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the group with the given tracking id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ChunkGroup> getChunkGroupWithHttpInfo( @NotNull String trDataset,  @NotNull UUID groupId) throws ApiException {
        okhttp3.Call localVarCall = getChunkGroupValidateBeforeCall(trDataset, groupId, null);
        Type localVarReturnType = new TypeToken<ChunkGroup>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Group (asynchronously)
     * Get Group  Fetch the group with the given id. get_group
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the group with the given tracking id </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the group with the given tracking id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunkGroupAsync(String trDataset, UUID groupId, final ApiCallback<ChunkGroup> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChunkGroupValidateBeforeCall(trDataset, groupId, _callback);
        Type localVarReturnType = new TypeToken<ChunkGroup>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getChunksInGroup
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param page The page of chunks to get from the group (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Chunks present within the specified group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunksInGroupCall(String trDataset, UUID groupId, Long page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk_group/{group_id}/{page}"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()))
            .replace("{" + "page" + "}", localVarApiClient.escapeString(page.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChunksInGroupValidateBeforeCall(String trDataset, UUID groupId, Long page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getChunksInGroup(Async)");
        }

        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling getChunksInGroup(Async)");
        }

        // verify the required parameter 'page' is set
        if (page == null) {
            throw new ApiException("Missing the required parameter 'page' when calling getChunksInGroup(Async)");
        }

        return getChunksInGroupCall(trDataset, groupId, page, _callback);

    }

    /**
     * Get Chunks in Group
     * Get Chunks in Group  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param page The page of chunks to get from the group (required)
     * @return BookmarkData
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Chunks present within the specified group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public BookmarkData getChunksInGroup(String trDataset, UUID groupId, Long page) throws ApiException {
        ApiResponse<BookmarkData> localVarResp = getChunksInGroupWithHttpInfo(trDataset, groupId, page);
        return localVarResp.getData();
    }

    /**
     * Get Chunks in Group
     * Get Chunks in Group  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param page The page of chunks to get from the group (required)
     * @return ApiResponse&lt;BookmarkData&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Chunks present within the specified group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BookmarkData> getChunksInGroupWithHttpInfo( @NotNull String trDataset,  @NotNull UUID groupId,  @NotNull  @Min(0L)Long page) throws ApiException {
        okhttp3.Call localVarCall = getChunksInGroupValidateBeforeCall(trDataset, groupId, page, null);
        Type localVarReturnType = new TypeToken<BookmarkData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Chunks in Group (asynchronously)
     * Get Chunks in Group  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group you want to fetch. (required)
     * @param page The page of chunks to get from the group (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Chunks present within the specified group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunksInGroupAsync(String trDataset, UUID groupId, Long page, final ApiCallback<BookmarkData> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChunksInGroupValidateBeforeCall(trDataset, groupId, page, _callback);
        Type localVarReturnType = new TypeToken<BookmarkData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getChunksInGroupByTrackingId
     * @param trDataset The dataset id to use for the request (required)
     * @param groupTrackingId The id of the group to get the chunks from (required)
     * @param page The page of chunks to get from the group (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Chunks present within the specified group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunksInGroupByTrackingIdCall(String trDataset, String groupTrackingId, Long page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk_group/tracking_id/{group_tracking_id}/{page}"
            .replace("{" + "group_tracking_id" + "}", localVarApiClient.escapeString(groupTrackingId.toString()))
            .replace("{" + "page" + "}", localVarApiClient.escapeString(page.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChunksInGroupByTrackingIdValidateBeforeCall(String trDataset, String groupTrackingId, Long page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getChunksInGroupByTrackingId(Async)");
        }

        // verify the required parameter 'groupTrackingId' is set
        if (groupTrackingId == null) {
            throw new ApiException("Missing the required parameter 'groupTrackingId' when calling getChunksInGroupByTrackingId(Async)");
        }

        // verify the required parameter 'page' is set
        if (page == null) {
            throw new ApiException("Missing the required parameter 'page' when calling getChunksInGroupByTrackingId(Async)");
        }

        return getChunksInGroupByTrackingIdCall(trDataset, groupTrackingId, page, _callback);

    }

    /**
     * Get Chunks in Group by Tracking ID
     * Get Chunks in Group by Tracking ID  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupTrackingId The id of the group to get the chunks from (required)
     * @param page The page of chunks to get from the group (required)
     * @return BookmarkData
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Chunks present within the specified group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public BookmarkData getChunksInGroupByTrackingId(String trDataset, String groupTrackingId, Long page) throws ApiException {
        ApiResponse<BookmarkData> localVarResp = getChunksInGroupByTrackingIdWithHttpInfo(trDataset, groupTrackingId, page);
        return localVarResp.getData();
    }

    /**
     * Get Chunks in Group by Tracking ID
     * Get Chunks in Group by Tracking ID  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupTrackingId The id of the group to get the chunks from (required)
     * @param page The page of chunks to get from the group (required)
     * @return ApiResponse&lt;BookmarkData&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Chunks present within the specified group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BookmarkData> getChunksInGroupByTrackingIdWithHttpInfo( @NotNull String trDataset,  @NotNull String groupTrackingId,  @NotNull  @Min(0L)Long page) throws ApiException {
        okhttp3.Call localVarCall = getChunksInGroupByTrackingIdValidateBeforeCall(trDataset, groupTrackingId, page, null);
        Type localVarReturnType = new TypeToken<BookmarkData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Chunks in Group by Tracking ID (asynchronously)
     * Get Chunks in Group by Tracking ID  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupTrackingId The id of the group to get the chunks from (required)
     * @param page The page of chunks to get from the group (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Chunks present within the specified group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunksInGroupByTrackingIdAsync(String trDataset, String groupTrackingId, Long page, final ApiCallback<BookmarkData> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChunksInGroupByTrackingIdValidateBeforeCall(trDataset, groupTrackingId, page, _callback);
        Type localVarReturnType = new TypeToken<BookmarkData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupByTrackingId
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId The tracking id of the group to fetch. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the group with the given tracking id </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the group with the given tracking id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupByTrackingIdCall(String trDataset, String trackingId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk_group/tracking_id/{tracking_id}"
            .replace("{" + "tracking_id" + "}", localVarApiClient.escapeString(trackingId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupByTrackingIdValidateBeforeCall(String trDataset, String trackingId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getGroupByTrackingId(Async)");
        }

        // verify the required parameter 'trackingId' is set
        if (trackingId == null) {
            throw new ApiException("Missing the required parameter 'trackingId' when calling getGroupByTrackingId(Async)");
        }

        return getGroupByTrackingIdCall(trDataset, trackingId, _callback);

    }

    /**
     * Get Group by Tracking ID
     * Get Group by Tracking ID  Fetch the group with the given tracking id. get_group_by_tracking_id
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId The tracking id of the group to fetch. (required)
     * @return ChunkGroup
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the group with the given tracking id </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the group with the given tracking id </td><td>  -  </td></tr>
     </table>
     */
    public ChunkGroup getGroupByTrackingId(String trDataset, String trackingId) throws ApiException {
        ApiResponse<ChunkGroup> localVarResp = getGroupByTrackingIdWithHttpInfo(trDataset, trackingId);
        return localVarResp.getData();
    }

    /**
     * Get Group by Tracking ID
     * Get Group by Tracking ID  Fetch the group with the given tracking id. get_group_by_tracking_id
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId The tracking id of the group to fetch. (required)
     * @return ApiResponse&lt;ChunkGroup&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the group with the given tracking id </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the group with the given tracking id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ChunkGroup> getGroupByTrackingIdWithHttpInfo( @NotNull String trDataset,  @NotNull String trackingId) throws ApiException {
        okhttp3.Call localVarCall = getGroupByTrackingIdValidateBeforeCall(trDataset, trackingId, null);
        Type localVarReturnType = new TypeToken<ChunkGroup>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Group by Tracking ID (asynchronously)
     * Get Group by Tracking ID  Fetch the group with the given tracking id. get_group_by_tracking_id
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId The tracking id of the group to fetch. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the group with the given tracking id </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the group with the given tracking id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupByTrackingIdAsync(String trDataset, String trackingId, final ApiCallback<ChunkGroup> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupByTrackingIdValidateBeforeCall(trDataset, trackingId, _callback);
        Type localVarReturnType = new TypeToken<ChunkGroup>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupsChunkIsIn
     * @param trDataset The dataset id to use for the request (required)
     * @param getGroupsForChunksData JSON request payload to get the groups that a chunk is in (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the groups that the chunk is in </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsChunkIsInCall(String trDataset, GetGroupsForChunksData getGroupsForChunksData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getGroupsForChunksData;

        // create path and map variables
        String localVarPath = "/api/chunk_group/chunks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupsChunkIsInValidateBeforeCall(String trDataset, GetGroupsForChunksData getGroupsForChunksData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getGroupsChunkIsIn(Async)");
        }

        // verify the required parameter 'getGroupsForChunksData' is set
        if (getGroupsForChunksData == null) {
            throw new ApiException("Missing the required parameter 'getGroupsForChunksData' when calling getGroupsChunkIsIn(Async)");
        }

        return getGroupsChunkIsInCall(trDataset, getGroupsForChunksData, _callback);

    }

    /**
     * Get Groups for Chunks
     * Get Groups for Chunks  Route to get the groups that a chunk is in.
     * @param trDataset The dataset id to use for the request (required)
     * @param getGroupsForChunksData JSON request payload to get the groups that a chunk is in (required)
     * @return List&lt;BookmarkGroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the groups that the chunk is in </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public List<BookmarkGroupResult> getGroupsChunkIsIn(String trDataset, GetGroupsForChunksData getGroupsForChunksData) throws ApiException {
        ApiResponse<List<BookmarkGroupResult>> localVarResp = getGroupsChunkIsInWithHttpInfo(trDataset, getGroupsForChunksData);
        return localVarResp.getData();
    }

    /**
     * Get Groups for Chunks
     * Get Groups for Chunks  Route to get the groups that a chunk is in.
     * @param trDataset The dataset id to use for the request (required)
     * @param getGroupsForChunksData JSON request payload to get the groups that a chunk is in (required)
     * @return ApiResponse&lt;List&lt;BookmarkGroupResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the groups that the chunk is in </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<BookmarkGroupResult>> getGroupsChunkIsInWithHttpInfo( @NotNull String trDataset,  @NotNull GetGroupsForChunksData getGroupsForChunksData) throws ApiException {
        okhttp3.Call localVarCall = getGroupsChunkIsInValidateBeforeCall(trDataset, getGroupsForChunksData, null);
        Type localVarReturnType = new TypeToken<List<BookmarkGroupResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Groups for Chunks (asynchronously)
     * Get Groups for Chunks  Route to get the groups that a chunk is in.
     * @param trDataset The dataset id to use for the request (required)
     * @param getGroupsForChunksData JSON request payload to get the groups that a chunk is in (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the groups that the chunk is in </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsChunkIsInAsync(String trDataset, GetGroupsForChunksData getGroupsForChunksData, final ApiCallback<List<BookmarkGroupResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupsChunkIsInValidateBeforeCall(trDataset, getGroupsForChunksData, _callback);
        Type localVarReturnType = new TypeToken<List<BookmarkGroupResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRecommendedGroups
     * @param trDataset The dataset id to use for the request (required)
     * @param reccomendGroupChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing chunks with scores which are similar to those in the request body </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to getting similar chunks </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecommendedGroupsCall(String trDataset, ReccomendGroupChunksRequest reccomendGroupChunksRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = reccomendGroupChunksRequest;

        // create path and map variables
        String localVarPath = "/api/chunk_group/recommend";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecommendedGroupsValidateBeforeCall(String trDataset, ReccomendGroupChunksRequest reccomendGroupChunksRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getRecommendedGroups(Async)");
        }

        // verify the required parameter 'reccomendGroupChunksRequest' is set
        if (reccomendGroupChunksRequest == null) {
            throw new ApiException("Missing the required parameter 'reccomendGroupChunksRequest' when calling getRecommendedGroups(Async)");
        }

        return getRecommendedGroupsCall(trDataset, reccomendGroupChunksRequest, _callback);

    }

    /**
     * Get Recommended Groups
     * Get Recommended Groups  Route to get recommended groups. This route will return groups which are similar to the groups in the request body.
     * @param trDataset The dataset id to use for the request (required)
     * @param reccomendGroupChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request (required)
     * @return List&lt;GroupScoreChunkDTO&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing chunks with scores which are similar to those in the request body </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to getting similar chunks </td><td>  -  </td></tr>
     </table>
     */
    public List<GroupScoreChunkDTO> getRecommendedGroups(String trDataset, ReccomendGroupChunksRequest reccomendGroupChunksRequest) throws ApiException {
        ApiResponse<List<GroupScoreChunkDTO>> localVarResp = getRecommendedGroupsWithHttpInfo(trDataset, reccomendGroupChunksRequest);
        return localVarResp.getData();
    }

    /**
     * Get Recommended Groups
     * Get Recommended Groups  Route to get recommended groups. This route will return groups which are similar to the groups in the request body.
     * @param trDataset The dataset id to use for the request (required)
     * @param reccomendGroupChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request (required)
     * @return ApiResponse&lt;List&lt;GroupScoreChunkDTO&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing chunks with scores which are similar to those in the request body </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to getting similar chunks </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<GroupScoreChunkDTO>> getRecommendedGroupsWithHttpInfo( @NotNull String trDataset,  @NotNull ReccomendGroupChunksRequest reccomendGroupChunksRequest) throws ApiException {
        okhttp3.Call localVarCall = getRecommendedGroupsValidateBeforeCall(trDataset, reccomendGroupChunksRequest, null);
        Type localVarReturnType = new TypeToken<List<GroupScoreChunkDTO>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Recommended Groups (asynchronously)
     * Get Recommended Groups  Route to get recommended groups. This route will return groups which are similar to the groups in the request body.
     * @param trDataset The dataset id to use for the request (required)
     * @param reccomendGroupChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing chunks with scores which are similar to those in the request body </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to getting similar chunks </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecommendedGroupsAsync(String trDataset, ReccomendGroupChunksRequest reccomendGroupChunksRequest, final ApiCallback<List<GroupScoreChunkDTO>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecommendedGroupsValidateBeforeCall(trDataset, reccomendGroupChunksRequest, _callback);
        Type localVarReturnType = new TypeToken<List<GroupScoreChunkDTO>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSpecificDatasetChunkGroups
     * @param trDataset The dataset id to use for the request (required)
     * @param datasetId The id of the dataset to fetch groups for. (required)
     * @param page The page of groups to fetch. Each page contains 10 groups. Support for custom page size is coming soon. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the groups created by the given dataset </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups created by the given dataset </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSpecificDatasetChunkGroupsCall(String trDataset, UUID datasetId, Long page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/dataset/groups/{dataset_id}/{page}"
            .replace("{" + "dataset_id" + "}", localVarApiClient.escapeString(datasetId.toString()))
            .replace("{" + "page" + "}", localVarApiClient.escapeString(page.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSpecificDatasetChunkGroupsValidateBeforeCall(String trDataset, UUID datasetId, Long page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getSpecificDatasetChunkGroups(Async)");
        }

        // verify the required parameter 'datasetId' is set
        if (datasetId == null) {
            throw new ApiException("Missing the required parameter 'datasetId' when calling getSpecificDatasetChunkGroups(Async)");
        }

        // verify the required parameter 'page' is set
        if (page == null) {
            throw new ApiException("Missing the required parameter 'page' when calling getSpecificDatasetChunkGroups(Async)");
        }

        return getSpecificDatasetChunkGroupsCall(trDataset, datasetId, page, _callback);

    }

    /**
     * Get Groups for Dataset
     * Get Groups for Dataset  Fetch the groups which belong to a dataset specified by its id.
     * @param trDataset The dataset id to use for the request (required)
     * @param datasetId The id of the dataset to fetch groups for. (required)
     * @param page The page of groups to fetch. Each page contains 10 groups. Support for custom page size is coming soon. (required)
     * @return GroupData
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the groups created by the given dataset </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups created by the given dataset </td><td>  -  </td></tr>
     </table>
     */
    public GroupData getSpecificDatasetChunkGroups(String trDataset, UUID datasetId, Long page) throws ApiException {
        ApiResponse<GroupData> localVarResp = getSpecificDatasetChunkGroupsWithHttpInfo(trDataset, datasetId, page);
        return localVarResp.getData();
    }

    /**
     * Get Groups for Dataset
     * Get Groups for Dataset  Fetch the groups which belong to a dataset specified by its id.
     * @param trDataset The dataset id to use for the request (required)
     * @param datasetId The id of the dataset to fetch groups for. (required)
     * @param page The page of groups to fetch. Each page contains 10 groups. Support for custom page size is coming soon. (required)
     * @return ApiResponse&lt;GroupData&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the groups created by the given dataset </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups created by the given dataset </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GroupData> getSpecificDatasetChunkGroupsWithHttpInfo( @NotNull String trDataset,  @NotNull UUID datasetId,  @NotNull Long page) throws ApiException {
        okhttp3.Call localVarCall = getSpecificDatasetChunkGroupsValidateBeforeCall(trDataset, datasetId, page, null);
        Type localVarReturnType = new TypeToken<GroupData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Groups for Dataset (asynchronously)
     * Get Groups for Dataset  Fetch the groups which belong to a dataset specified by its id.
     * @param trDataset The dataset id to use for the request (required)
     * @param datasetId The id of the dataset to fetch groups for. (required)
     * @param page The page of groups to fetch. Each page contains 10 groups. Support for custom page size is coming soon. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON body representing the groups created by the given dataset </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups created by the given dataset </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSpecificDatasetChunkGroupsAsync(String trDataset, UUID datasetId, Long page, final ApiCallback<GroupData> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSpecificDatasetChunkGroupsValidateBeforeCall(trDataset, datasetId, page, _callback);
        Type localVarReturnType = new TypeToken<GroupData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for removeChunkFromGroup
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group to remove the bookmark&#39;ed chunk from (required)
     * @param createChunkGroupData JSON request payload to cretea a chunkGroup (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was removed to the group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to removing the chunk from the group </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call removeChunkFromGroupCall(String trDataset, UUID groupId, CreateChunkGroupData createChunkGroupData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createChunkGroupData;

        // create path and map variables
        String localVarPath = "/api/chunk_group/chunk/{group_id}"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call removeChunkFromGroupValidateBeforeCall(String trDataset, UUID groupId, CreateChunkGroupData createChunkGroupData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling removeChunkFromGroup(Async)");
        }

        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling removeChunkFromGroup(Async)");
        }

        // verify the required parameter 'createChunkGroupData' is set
        if (createChunkGroupData == null) {
            throw new ApiException("Missing the required parameter 'createChunkGroupData' when calling removeChunkFromGroup(Async)");
        }

        return removeChunkFromGroupCall(trDataset, groupId, createChunkGroupData, _callback);

    }

    /**
     * Remove Chunk from Group
     * Remove Chunk from Group  Route to remove a chunk from a group.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group to remove the bookmark&#39;ed chunk from (required)
     * @param createChunkGroupData JSON request payload to cretea a chunkGroup (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was removed to the group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to removing the chunk from the group </td><td>  -  </td></tr>
     </table>
     */
    public void removeChunkFromGroup(String trDataset, UUID groupId, CreateChunkGroupData createChunkGroupData) throws ApiException {
        removeChunkFromGroupWithHttpInfo(trDataset, groupId, createChunkGroupData);
    }

    /**
     * Remove Chunk from Group
     * Remove Chunk from Group  Route to remove a chunk from a group.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group to remove the bookmark&#39;ed chunk from (required)
     * @param createChunkGroupData JSON request payload to cretea a chunkGroup (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was removed to the group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to removing the chunk from the group </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> removeChunkFromGroupWithHttpInfo( @NotNull String trDataset,  @NotNull UUID groupId,  @NotNull CreateChunkGroupData createChunkGroupData) throws ApiException {
        okhttp3.Call localVarCall = removeChunkFromGroupValidateBeforeCall(trDataset, groupId, createChunkGroupData, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Remove Chunk from Group (asynchronously)
     * Remove Chunk from Group  Route to remove a chunk from a group.
     * @param trDataset The dataset id to use for the request (required)
     * @param groupId Id of the group to remove the bookmark&#39;ed chunk from (required)
     * @param createChunkGroupData JSON request payload to cretea a chunkGroup (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk was removed to the group </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to removing the chunk from the group </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call removeChunkFromGroupAsync(String trDataset, UUID groupId, CreateChunkGroupData createChunkGroupData, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = removeChunkFromGroupValidateBeforeCall(trDataset, groupId, createChunkGroupData, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchOverGroups
     * @param searchOverGroupsData JSON request payload to semantically search over groups (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchOverGroupsCall(SearchOverGroupsData searchOverGroupsData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchOverGroupsData;

        // create path and map variables
        String localVarPath = "/api/chunk_group/group_oriented_search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchOverGroupsValidateBeforeCall(SearchOverGroupsData searchOverGroupsData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'searchOverGroupsData' is set
        if (searchOverGroupsData == null) {
            throw new ApiException("Missing the required parameter 'searchOverGroupsData' when calling searchOverGroups(Async)");
        }

        return searchOverGroupsCall(searchOverGroupsData, _callback);

    }

    /**
     * Search Over Groups
     * Search Over Groups  This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
     * @param searchOverGroupsData JSON request payload to semantically search over groups (required)
     * @return SearchOverGroupsResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public SearchOverGroupsResponseBody searchOverGroups(SearchOverGroupsData searchOverGroupsData) throws ApiException {
        ApiResponse<SearchOverGroupsResponseBody> localVarResp = searchOverGroupsWithHttpInfo(searchOverGroupsData);
        return localVarResp.getData();
    }

    /**
     * Search Over Groups
     * Search Over Groups  This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
     * @param searchOverGroupsData JSON request payload to semantically search over groups (required)
     * @return ApiResponse&lt;SearchOverGroupsResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SearchOverGroupsResponseBody> searchOverGroupsWithHttpInfo( @NotNull SearchOverGroupsData searchOverGroupsData) throws ApiException {
        okhttp3.Call localVarCall = searchOverGroupsValidateBeforeCall(searchOverGroupsData, null);
        Type localVarReturnType = new TypeToken<SearchOverGroupsResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Over Groups (asynchronously)
     * Search Over Groups  This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
     * @param searchOverGroupsData JSON request payload to semantically search over groups (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchOverGroupsAsync(SearchOverGroupsData searchOverGroupsData, final ApiCallback<SearchOverGroupsResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchOverGroupsValidateBeforeCall(searchOverGroupsData, _callback);
        Type localVarReturnType = new TypeToken<SearchOverGroupsResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchWithinGroup
     * @param trDataset The dataset id to use for the request (required)
     * @param searchWithinGroupData JSON request payload to semantically search a group (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchWithinGroupCall(String trDataset, SearchWithinGroupData searchWithinGroupData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchWithinGroupData;

        // create path and map variables
        String localVarPath = "/api/chunk_group/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchWithinGroupValidateBeforeCall(String trDataset, SearchWithinGroupData searchWithinGroupData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling searchWithinGroup(Async)");
        }

        // verify the required parameter 'searchWithinGroupData' is set
        if (searchWithinGroupData == null) {
            throw new ApiException("Missing the required parameter 'searchWithinGroupData' when calling searchWithinGroup(Async)");
        }

        return searchWithinGroupCall(trDataset, searchWithinGroupData, _callback);

    }

    /**
     * Search Within Group
     * Search Within Group  This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
     * @param trDataset The dataset id to use for the request (required)
     * @param searchWithinGroupData JSON request payload to semantically search a group (required)
     * @return SearchGroupsResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public SearchGroupsResult searchWithinGroup(String trDataset, SearchWithinGroupData searchWithinGroupData) throws ApiException {
        ApiResponse<SearchGroupsResult> localVarResp = searchWithinGroupWithHttpInfo(trDataset, searchWithinGroupData);
        return localVarResp.getData();
    }

    /**
     * Search Within Group
     * Search Within Group  This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
     * @param trDataset The dataset id to use for the request (required)
     * @param searchWithinGroupData JSON request payload to semantically search a group (required)
     * @return ApiResponse&lt;SearchGroupsResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SearchGroupsResult> searchWithinGroupWithHttpInfo( @NotNull String trDataset,  @NotNull SearchWithinGroupData searchWithinGroupData) throws ApiException {
        okhttp3.Call localVarCall = searchWithinGroupValidateBeforeCall(trDataset, searchWithinGroupData, null);
        Type localVarReturnType = new TypeToken<SearchGroupsResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Within Group (asynchronously)
     * Search Within Group  This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
     * @param trDataset The dataset id to use for the request (required)
     * @param searchWithinGroupData JSON request payload to semantically search a group (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to getting the groups that the chunk is in </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchWithinGroupAsync(String trDataset, SearchWithinGroupData searchWithinGroupData, final ApiCallback<SearchGroupsResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchWithinGroupValidateBeforeCall(trDataset, searchWithinGroupData, _callback);
        Type localVarReturnType = new TypeToken<SearchGroupsResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateChunkGroup
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkGroupData JSON request payload to update a chunkGroup (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to updating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateChunkGroupCall(String trDataset, UpdateChunkGroupData updateChunkGroupData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateChunkGroupData;

        // create path and map variables
        String localVarPath = "/api/chunk_group";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateChunkGroupValidateBeforeCall(String trDataset, UpdateChunkGroupData updateChunkGroupData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling updateChunkGroup(Async)");
        }

        // verify the required parameter 'updateChunkGroupData' is set
        if (updateChunkGroupData == null) {
            throw new ApiException("Missing the required parameter 'updateChunkGroupData' when calling updateChunkGroup(Async)");
        }

        return updateChunkGroupCall(trDataset, updateChunkGroupData, _callback);

    }

    /**
     * Update Group
     * Update Group  Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail.
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkGroupData JSON request payload to update a chunkGroup (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to updating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public void updateChunkGroup(String trDataset, UpdateChunkGroupData updateChunkGroupData) throws ApiException {
        updateChunkGroupWithHttpInfo(trDataset, updateChunkGroupData);
    }

    /**
     * Update Group
     * Update Group  Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail.
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkGroupData JSON request payload to update a chunkGroup (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to updating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> updateChunkGroupWithHttpInfo( @NotNull String trDataset,  @NotNull UpdateChunkGroupData updateChunkGroupData) throws ApiException {
        okhttp3.Call localVarCall = updateChunkGroupValidateBeforeCall(trDataset, updateChunkGroupData, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update Group (asynchronously)
     * Update Group  Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail.
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkGroupData JSON request payload to update a chunkGroup (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to updating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateChunkGroupAsync(String trDataset, UpdateChunkGroupData updateChunkGroupData, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateChunkGroupValidateBeforeCall(trDataset, updateChunkGroupData, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateGroupByTrackingId
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Tracking id of the chunk_group to update (required)
     * @param updateGroupByTrackingIDData JSON request payload to update a chunkGroup (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to updating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateGroupByTrackingIdCall(String trDataset, UUID trackingId, UpdateGroupByTrackingIDData updateGroupByTrackingIDData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateGroupByTrackingIDData;

        // create path and map variables
        String localVarPath = "/api/chunk_group/tracking_id/{tracking_id}"
            .replace("{" + "tracking_id" + "}", localVarApiClient.escapeString(trackingId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateGroupByTrackingIdValidateBeforeCall(String trDataset, UUID trackingId, UpdateGroupByTrackingIDData updateGroupByTrackingIDData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling updateGroupByTrackingId(Async)");
        }

        // verify the required parameter 'trackingId' is set
        if (trackingId == null) {
            throw new ApiException("Missing the required parameter 'trackingId' when calling updateGroupByTrackingId(Async)");
        }

        // verify the required parameter 'updateGroupByTrackingIDData' is set
        if (updateGroupByTrackingIDData == null) {
            throw new ApiException("Missing the required parameter 'updateGroupByTrackingIDData' when calling updateGroupByTrackingId(Async)");
        }

        return updateGroupByTrackingIdCall(trDataset, trackingId, updateGroupByTrackingIDData, _callback);

    }

    /**
     * Update Group by Tracking ID
     * Update Group by Tracking ID  Update a chunk_group with the given tracking id.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Tracking id of the chunk_group to update (required)
     * @param updateGroupByTrackingIDData JSON request payload to update a chunkGroup (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to updating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public void updateGroupByTrackingId(String trDataset, UUID trackingId, UpdateGroupByTrackingIDData updateGroupByTrackingIDData) throws ApiException {
        updateGroupByTrackingIdWithHttpInfo(trDataset, trackingId, updateGroupByTrackingIDData);
    }

    /**
     * Update Group by Tracking ID
     * Update Group by Tracking ID  Update a chunk_group with the given tracking id.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Tracking id of the chunk_group to update (required)
     * @param updateGroupByTrackingIDData JSON request payload to update a chunkGroup (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to updating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> updateGroupByTrackingIdWithHttpInfo( @NotNull String trDataset,  @NotNull UUID trackingId,  @NotNull UpdateGroupByTrackingIDData updateGroupByTrackingIDData) throws ApiException {
        okhttp3.Call localVarCall = updateGroupByTrackingIdValidateBeforeCall(trDataset, trackingId, updateGroupByTrackingIDData, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update Group by Tracking ID (asynchronously)
     * Update Group by Tracking ID  Update a chunk_group with the given tracking id.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId Tracking id of the chunk_group to update (required)
     * @param updateGroupByTrackingIDData JSON request payload to update a chunkGroup (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunkGroup was updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to updating the chunkGroup </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateGroupByTrackingIdAsync(String trDataset, UUID trackingId, UpdateGroupByTrackingIDData updateGroupByTrackingIDData, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateGroupByTrackingIdValidateBeforeCall(trDataset, trackingId, updateGroupByTrackingIDData, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}

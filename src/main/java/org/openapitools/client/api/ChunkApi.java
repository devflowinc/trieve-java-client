/*
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import javax.validation.constraints.*;
import javax.validation.Valid;

import org.openapitools.client.model.ChunkMetadata;
import org.openapitools.client.model.ChunkMetadataWithFileData;
import org.openapitools.client.model.CreateChunkData;
import org.openapitools.client.model.ErrorResponseBody;
import org.openapitools.client.model.GenerateChunksRequest;
import org.openapitools.client.model.RecommendChunksRequest;
import org.openapitools.client.model.ReturnQueuedChunk;
import org.openapitools.client.model.SearchChunkData;
import org.openapitools.client.model.SearchChunkQueryResponseBody;
import org.openapitools.client.model.SuggestedQueriesRequest;
import org.openapitools.client.model.SuggestedQueriesResponse;
import java.util.UUID;
import org.openapitools.client.model.UpdateChunkByTrackingIdData;
import org.openapitools.client.model.UpdateChunkData;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ChunkApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ChunkApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ChunkApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createChunk
     * @param trDataset The dataset id to use for the request (required)
     * @param createChunkData JSON request payload to create a new chunk (chunk) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing the created chunk </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error typically due to deserialization issues </td><td>  -  </td></tr>
        <tr><td> 426 </td><td> Error when upgrade is needed to process more chunks </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createChunkCall(String trDataset, CreateChunkData createChunkData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createChunkData;

        // create path and map variables
        String localVarPath = "/api/chunk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createChunkValidateBeforeCall(String trDataset, CreateChunkData createChunkData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling createChunk(Async)");
        }

        // verify the required parameter 'createChunkData' is set
        if (createChunkData == null) {
            throw new ApiException("Missing the required parameter 'createChunkData' when calling createChunk(Async)");
        }

        return createChunkCall(trDataset, createChunkData, _callback);

    }

    /**
     * Create or Upsert Chunk or Chunks
     * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
     * @param trDataset The dataset id to use for the request (required)
     * @param createChunkData JSON request payload to create a new chunk (chunk) (required)
     * @return ReturnQueuedChunk
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing the created chunk </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error typically due to deserialization issues </td><td>  -  </td></tr>
        <tr><td> 426 </td><td> Error when upgrade is needed to process more chunks </td><td>  -  </td></tr>
     </table>
     */
    public ReturnQueuedChunk createChunk(String trDataset, CreateChunkData createChunkData) throws ApiException {
        ApiResponse<ReturnQueuedChunk> localVarResp = createChunkWithHttpInfo(trDataset, createChunkData);
        return localVarResp.getData();
    }

    /**
     * Create or Upsert Chunk or Chunks
     * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
     * @param trDataset The dataset id to use for the request (required)
     * @param createChunkData JSON request payload to create a new chunk (chunk) (required)
     * @return ApiResponse&lt;ReturnQueuedChunk&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing the created chunk </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error typically due to deserialization issues </td><td>  -  </td></tr>
        <tr><td> 426 </td><td> Error when upgrade is needed to process more chunks </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReturnQueuedChunk> createChunkWithHttpInfo( @NotNull String trDataset,  @NotNull CreateChunkData createChunkData) throws ApiException {
        okhttp3.Call localVarCall = createChunkValidateBeforeCall(trDataset, createChunkData, null);
        Type localVarReturnType = new TypeToken<ReturnQueuedChunk>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create or Upsert Chunk or Chunks (asynchronously)
     * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
     * @param trDataset The dataset id to use for the request (required)
     * @param createChunkData JSON request payload to create a new chunk (chunk) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing the created chunk </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error typically due to deserialization issues </td><td>  -  </td></tr>
        <tr><td> 426 </td><td> Error when upgrade is needed to process more chunks </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createChunkAsync(String trDataset, CreateChunkData createChunkData, final ApiCallback<ReturnQueuedChunk> _callback) throws ApiException {

        okhttp3.Call localVarCall = createChunkValidateBeforeCall(trDataset, createChunkData, _callback);
        Type localVarReturnType = new TypeToken<ReturnQueuedChunk>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createSuggestedQueriesHandler
     * @param trDataset The dataset id to use for the request (required)
     * @param suggestedQueriesRequest JSON request payload to get alternative suggested queries (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A JSON object containing a list of alternative suggested queries </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSuggestedQueriesHandlerCall(String trDataset, SuggestedQueriesRequest suggestedQueriesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = suggestedQueriesRequest;

        // create path and map variables
        String localVarPath = "/api/chunk/gen_suggestions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSuggestedQueriesHandlerValidateBeforeCall(String trDataset, SuggestedQueriesRequest suggestedQueriesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling createSuggestedQueriesHandler(Async)");
        }

        // verify the required parameter 'suggestedQueriesRequest' is set
        if (suggestedQueriesRequest == null) {
            throw new ApiException("Missing the required parameter 'suggestedQueriesRequest' when calling createSuggestedQueriesHandler(Async)");
        }

        return createSuggestedQueriesHandlerCall(trDataset, suggestedQueriesRequest, _callback);

    }

    /**
     * Generate suggested queries
     * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
     * @param trDataset The dataset id to use for the request (required)
     * @param suggestedQueriesRequest JSON request payload to get alternative suggested queries (required)
     * @return SuggestedQueriesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A JSON object containing a list of alternative suggested queries </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public SuggestedQueriesResponse createSuggestedQueriesHandler(String trDataset, SuggestedQueriesRequest suggestedQueriesRequest) throws ApiException {
        ApiResponse<SuggestedQueriesResponse> localVarResp = createSuggestedQueriesHandlerWithHttpInfo(trDataset, suggestedQueriesRequest);
        return localVarResp.getData();
    }

    /**
     * Generate suggested queries
     * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
     * @param trDataset The dataset id to use for the request (required)
     * @param suggestedQueriesRequest JSON request payload to get alternative suggested queries (required)
     * @return ApiResponse&lt;SuggestedQueriesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A JSON object containing a list of alternative suggested queries </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SuggestedQueriesResponse> createSuggestedQueriesHandlerWithHttpInfo( @NotNull String trDataset,  @NotNull SuggestedQueriesRequest suggestedQueriesRequest) throws ApiException {
        okhttp3.Call localVarCall = createSuggestedQueriesHandlerValidateBeforeCall(trDataset, suggestedQueriesRequest, null);
        Type localVarReturnType = new TypeToken<SuggestedQueriesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Generate suggested queries (asynchronously)
     * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
     * @param trDataset The dataset id to use for the request (required)
     * @param suggestedQueriesRequest JSON request payload to get alternative suggested queries (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A JSON object containing a list of alternative suggested queries </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSuggestedQueriesHandlerAsync(String trDataset, SuggestedQueriesRequest suggestedQueriesRequest, final ApiCallback<SuggestedQueriesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createSuggestedQueriesHandlerValidateBeforeCall(trDataset, suggestedQueriesRequest, _callback);
        Type localVarReturnType = new TypeToken<SuggestedQueriesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteChunk
     * @param trDataset The dataset id to use for the request (required)
     * @param chunkId Id of the chunk you want to fetch. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk with the id specified was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to finding a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteChunkCall(String trDataset, UUID chunkId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk/{chunk_id}"
            .replace("{" + "chunk_id" + "}", localVarApiClient.escapeString(chunkId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteChunkValidateBeforeCall(String trDataset, UUID chunkId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling deleteChunk(Async)");
        }

        // verify the required parameter 'chunkId' is set
        if (chunkId == null) {
            throw new ApiException("Missing the required parameter 'chunkId' when calling deleteChunk(Async)");
        }

        return deleteChunkCall(trDataset, chunkId, _callback);

    }

    /**
     * Delete Chunk
     * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param chunkId Id of the chunk you want to fetch. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk with the id specified was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to finding a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public void deleteChunk(String trDataset, UUID chunkId) throws ApiException {
        deleteChunkWithHttpInfo(trDataset, chunkId);
    }

    /**
     * Delete Chunk
     * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param chunkId Id of the chunk you want to fetch. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk with the id specified was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to finding a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteChunkWithHttpInfo( @NotNull String trDataset,  @NotNull UUID chunkId) throws ApiException {
        okhttp3.Call localVarCall = deleteChunkValidateBeforeCall(trDataset, chunkId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Chunk (asynchronously)
     * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param chunkId Id of the chunk you want to fetch. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk with the id specified was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to finding a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteChunkAsync(String trDataset, UUID chunkId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteChunkValidateBeforeCall(trDataset, chunkId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteChunkByTrackingId
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId tracking_id of the chunk you want to delete (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk with the tracking_id specified was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to finding a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteChunkByTrackingIdCall(String trDataset, String trackingId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk/tracking_id/{tracking_id}"
            .replace("{" + "tracking_id" + "}", localVarApiClient.escapeString(trackingId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteChunkByTrackingIdValidateBeforeCall(String trDataset, String trackingId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling deleteChunkByTrackingId(Async)");
        }

        // verify the required parameter 'trackingId' is set
        if (trackingId == null) {
            throw new ApiException("Missing the required parameter 'trackingId' when calling deleteChunkByTrackingId(Async)");
        }

        return deleteChunkByTrackingIdCall(trDataset, trackingId, _callback);

    }

    /**
     * Delete Chunk By Tracking Id
     * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId tracking_id of the chunk you want to delete (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk with the tracking_id specified was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to finding a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public void deleteChunkByTrackingId(String trDataset, String trackingId) throws ApiException {
        deleteChunkByTrackingIdWithHttpInfo(trDataset, trackingId);
    }

    /**
     * Delete Chunk By Tracking Id
     * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId tracking_id of the chunk you want to delete (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk with the tracking_id specified was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to finding a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteChunkByTrackingIdWithHttpInfo( @NotNull String trDataset,  @NotNull String trackingId) throws ApiException {
        okhttp3.Call localVarCall = deleteChunkByTrackingIdValidateBeforeCall(trDataset, trackingId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Chunk By Tracking Id (asynchronously)
     * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId tracking_id of the chunk you want to delete (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk with the tracking_id specified was deleted </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to finding a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteChunkByTrackingIdAsync(String trDataset, String trackingId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteChunkByTrackingIdValidateBeforeCall(trDataset, trackingId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for generateOffChunks
     * @param trDataset The dataset id to use for the request (required)
     * @param generateChunksRequest JSON request payload to perform RAG on some chunks (chunks) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call generateOffChunksCall(String trDataset, GenerateChunksRequest generateChunksRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = generateChunksRequest;

        // create path and map variables
        String localVarPath = "/api/chunk/generate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call generateOffChunksValidateBeforeCall(String trDataset, GenerateChunksRequest generateChunksRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling generateOffChunks(Async)");
        }

        // verify the required parameter 'generateChunksRequest' is set
        if (generateChunksRequest == null) {
            throw new ApiException("Missing the required parameter 'generateChunksRequest' when calling generateOffChunks(Async)");
        }

        return generateOffChunksCall(trDataset, generateChunksRequest, _callback);

    }

    /**
     * RAG on Specified Chunks
     * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \&quot;search before generate\&quot; page at docs.trieve.ai.
     * @param trDataset The dataset id to use for the request (required)
     * @param generateChunksRequest JSON request payload to perform RAG on some chunks (chunks) (required)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public String generateOffChunks(String trDataset, GenerateChunksRequest generateChunksRequest) throws ApiException {
        ApiResponse<String> localVarResp = generateOffChunksWithHttpInfo(trDataset, generateChunksRequest);
        return localVarResp.getData();
    }

    /**
     * RAG on Specified Chunks
     * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \&quot;search before generate\&quot; page at docs.trieve.ai.
     * @param trDataset The dataset id to use for the request (required)
     * @param generateChunksRequest JSON request payload to perform RAG on some chunks (chunks) (required)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> generateOffChunksWithHttpInfo( @NotNull String trDataset,  @NotNull GenerateChunksRequest generateChunksRequest) throws ApiException {
        okhttp3.Call localVarCall = generateOffChunksValidateBeforeCall(trDataset, generateChunksRequest, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * RAG on Specified Chunks (asynchronously)
     * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \&quot;search before generate\&quot; page at docs.trieve.ai.
     * @param trDataset The dataset id to use for the request (required)
     * @param generateChunksRequest JSON request payload to perform RAG on some chunks (chunks) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This will be a JSON response of a string containing the LLM&#39;s generated inference. Response if not streaming. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call generateOffChunksAsync(String trDataset, GenerateChunksRequest generateChunksRequest, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = generateOffChunksValidateBeforeCall(trDataset, generateChunksRequest, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getChunkById
     * @param trDataset The dataset id to use for the request (required)
     * @param chunkId Id of the chunk you want to fetch. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunk with the id that you were searching for </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to fidning a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunkByIdCall(String trDataset, UUID chunkId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk/{chunk_id}"
            .replace("{" + "chunk_id" + "}", localVarApiClient.escapeString(chunkId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChunkByIdValidateBeforeCall(String trDataset, UUID chunkId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getChunkById(Async)");
        }

        // verify the required parameter 'chunkId' is set
        if (chunkId == null) {
            throw new ApiException("Missing the required parameter 'chunkId' when calling getChunkById(Async)");
        }

        return getChunkByIdCall(trDataset, chunkId, _callback);

    }

    /**
     * Get Chunk By Id
     * Get Chunk By Id  Get a singular chunk by id.
     * @param trDataset The dataset id to use for the request (required)
     * @param chunkId Id of the chunk you want to fetch. (required)
     * @return ChunkMetadata
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunk with the id that you were searching for </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to fidning a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public ChunkMetadata getChunkById(String trDataset, UUID chunkId) throws ApiException {
        ApiResponse<ChunkMetadata> localVarResp = getChunkByIdWithHttpInfo(trDataset, chunkId);
        return localVarResp.getData();
    }

    /**
     * Get Chunk By Id
     * Get Chunk By Id  Get a singular chunk by id.
     * @param trDataset The dataset id to use for the request (required)
     * @param chunkId Id of the chunk you want to fetch. (required)
     * @return ApiResponse&lt;ChunkMetadata&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunk with the id that you were searching for </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to fidning a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ChunkMetadata> getChunkByIdWithHttpInfo( @NotNull String trDataset,  @NotNull UUID chunkId) throws ApiException {
        okhttp3.Call localVarCall = getChunkByIdValidateBeforeCall(trDataset, chunkId, null);
        Type localVarReturnType = new TypeToken<ChunkMetadata>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Chunk By Id (asynchronously)
     * Get Chunk By Id  Get a singular chunk by id.
     * @param trDataset The dataset id to use for the request (required)
     * @param chunkId Id of the chunk you want to fetch. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunk with the id that you were searching for </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to fidning a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunkByIdAsync(String trDataset, UUID chunkId, final ApiCallback<ChunkMetadata> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChunkByIdValidateBeforeCall(trDataset, chunkId, _callback);
        Type localVarReturnType = new TypeToken<ChunkMetadata>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getChunkByTrackingId
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId tracking_id of the chunk you want to fetch (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunk with the tracking_id that you were searching for </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to fidning a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunkByTrackingIdCall(String trDataset, String trackingId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chunk/tracking_id/{tracking_id}"
            .replace("{" + "tracking_id" + "}", localVarApiClient.escapeString(trackingId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChunkByTrackingIdValidateBeforeCall(String trDataset, String trackingId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getChunkByTrackingId(Async)");
        }

        // verify the required parameter 'trackingId' is set
        if (trackingId == null) {
            throw new ApiException("Missing the required parameter 'trackingId' when calling getChunkByTrackingId(Async)");
        }

        return getChunkByTrackingIdCall(trDataset, trackingId, _callback);

    }

    /**
     * Get Chunk By Tracking Id
     * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId tracking_id of the chunk you want to fetch (required)
     * @return ChunkMetadata
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunk with the tracking_id that you were searching for </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to fidning a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public ChunkMetadata getChunkByTrackingId(String trDataset, String trackingId) throws ApiException {
        ApiResponse<ChunkMetadata> localVarResp = getChunkByTrackingIdWithHttpInfo(trDataset, trackingId);
        return localVarResp.getData();
    }

    /**
     * Get Chunk By Tracking Id
     * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId tracking_id of the chunk you want to fetch (required)
     * @return ApiResponse&lt;ChunkMetadata&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunk with the tracking_id that you were searching for </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to fidning a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ChunkMetadata> getChunkByTrackingIdWithHttpInfo( @NotNull String trDataset,  @NotNull String trackingId) throws ApiException {
        okhttp3.Call localVarCall = getChunkByTrackingIdValidateBeforeCall(trDataset, trackingId, null);
        Type localVarReturnType = new TypeToken<ChunkMetadata>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Chunk By Tracking Id (asynchronously)
     * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param trackingId tracking_id of the chunk you want to fetch (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunk with the tracking_id that you were searching for </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to fidning a chunk by tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChunkByTrackingIdAsync(String trDataset, String trackingId, final ApiCallback<ChunkMetadata> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChunkByTrackingIdValidateBeforeCall(trDataset, trackingId, _callback);
        Type localVarReturnType = new TypeToken<ChunkMetadata>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRecommendedChunks
     * @param trDataset The dataset id to use for the request (required)
     * @param recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing chunks with scores which are similar to those in the request body </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to getting similar chunks </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecommendedChunksCall(String trDataset, RecommendChunksRequest recommendChunksRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = recommendChunksRequest;

        // create path and map variables
        String localVarPath = "/api/chunk/recommend";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecommendedChunksValidateBeforeCall(String trDataset, RecommendChunksRequest recommendChunksRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling getRecommendedChunks(Async)");
        }

        // verify the required parameter 'recommendChunksRequest' is set
        if (recommendChunksRequest == null) {
            throw new ApiException("Missing the required parameter 'recommendChunksRequest' when calling getRecommendedChunks(Async)");
        }

        return getRecommendedChunksCall(trDataset, recommendChunksRequest, _callback);

    }

    /**
     * Get Recommended Chunks
     * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \&quot;add to playlist\&quot; recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
     * @param trDataset The dataset id to use for the request (required)
     * @param recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request (required)
     * @return List&lt;ChunkMetadataWithFileData&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing chunks with scores which are similar to those in the request body </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to getting similar chunks </td><td>  -  </td></tr>
     </table>
     */
    public List<ChunkMetadataWithFileData> getRecommendedChunks(String trDataset, RecommendChunksRequest recommendChunksRequest) throws ApiException {
        ApiResponse<List<ChunkMetadataWithFileData>> localVarResp = getRecommendedChunksWithHttpInfo(trDataset, recommendChunksRequest);
        return localVarResp.getData();
    }

    /**
     * Get Recommended Chunks
     * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \&quot;add to playlist\&quot; recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
     * @param trDataset The dataset id to use for the request (required)
     * @param recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request (required)
     * @return ApiResponse&lt;List&lt;ChunkMetadataWithFileData&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing chunks with scores which are similar to those in the request body </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to getting similar chunks </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ChunkMetadataWithFileData>> getRecommendedChunksWithHttpInfo( @NotNull String trDataset,  @NotNull RecommendChunksRequest recommendChunksRequest) throws ApiException {
        okhttp3.Call localVarCall = getRecommendedChunksValidateBeforeCall(trDataset, recommendChunksRequest, null);
        Type localVarReturnType = new TypeToken<List<ChunkMetadataWithFileData>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Recommended Chunks (asynchronously)
     * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \&quot;add to playlist\&quot; recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
     * @param trDataset The dataset id to use for the request (required)
     * @param recommendChunksRequest JSON request payload to get recommendations of chunks similar to the chunks in the request (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> JSON response payload containing chunks with scores which are similar to those in the request body </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to getting similar chunks </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecommendedChunksAsync(String trDataset, RecommendChunksRequest recommendChunksRequest, final ApiCallback<List<ChunkMetadataWithFileData>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecommendedChunksValidateBeforeCall(trDataset, recommendChunksRequest, _callback);
        Type localVarReturnType = new TypeToken<List<ChunkMetadataWithFileData>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchChunk
     * @param trDataset The dataset id to use for the request (required)
     * @param searchChunkData JSON request payload to semantically search for chunks (chunks) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to searching </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchChunkCall(String trDataset, SearchChunkData searchChunkData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchChunkData;

        // create path and map variables
        String localVarPath = "/api/chunk/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchChunkValidateBeforeCall(String trDataset, SearchChunkData searchChunkData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling searchChunk(Async)");
        }

        // verify the required parameter 'searchChunkData' is set
        if (searchChunkData == null) {
            throw new ApiException("Missing the required parameter 'searchChunkData' when calling searchChunk(Async)");
        }

        return searchChunkCall(trDataset, searchChunkData, _callback);

    }

    /**
     * Search
     * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results&#39; &#x60;chunk_html&#x60; values will be modified with &#x60;&lt;b&gt;&#x60; tags for sub-sentence highlighting.
     * @param trDataset The dataset id to use for the request (required)
     * @param searchChunkData JSON request payload to semantically search for chunks (chunks) (required)
     * @return SearchChunkQueryResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to searching </td><td>  -  </td></tr>
     </table>
     */
    public SearchChunkQueryResponseBody searchChunk(String trDataset, SearchChunkData searchChunkData) throws ApiException {
        ApiResponse<SearchChunkQueryResponseBody> localVarResp = searchChunkWithHttpInfo(trDataset, searchChunkData);
        return localVarResp.getData();
    }

    /**
     * Search
     * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results&#39; &#x60;chunk_html&#x60; values will be modified with &#x60;&lt;b&gt;&#x60; tags for sub-sentence highlighting.
     * @param trDataset The dataset id to use for the request (required)
     * @param searchChunkData JSON request payload to semantically search for chunks (chunks) (required)
     * @return ApiResponse&lt;SearchChunkQueryResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to searching </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SearchChunkQueryResponseBody> searchChunkWithHttpInfo( @NotNull String trDataset,  @NotNull SearchChunkData searchChunkData) throws ApiException {
        okhttp3.Call localVarCall = searchChunkValidateBeforeCall(trDataset, searchChunkData, null);
        Type localVarReturnType = new TypeToken<SearchChunkQueryResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search (asynchronously)
     * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results&#39; &#x60;chunk_html&#x60; values will be modified with &#x60;&lt;b&gt;&#x60; tags for sub-sentence highlighting.
     * @param trDataset The dataset id to use for the request (required)
     * @param searchChunkData JSON request payload to semantically search for chunks (chunks) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> chunks which are similar to the embedding vector of the search query </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to searching </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchChunkAsync(String trDataset, SearchChunkData searchChunkData, final ApiCallback<SearchChunkQueryResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchChunkValidateBeforeCall(trDataset, searchChunkData, _callback);
        Type localVarReturnType = new TypeToken<SearchChunkQueryResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateChunk
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkData JSON request payload to update a chunk (chunk) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content Ok response indicating the chunk was updated as requested </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateChunkCall(String trDataset, UpdateChunkData updateChunkData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateChunkData;

        // create path and map variables
        String localVarPath = "/api/chunk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateChunkValidateBeforeCall(String trDataset, UpdateChunkData updateChunkData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling updateChunk(Async)");
        }

        // verify the required parameter 'updateChunkData' is set
        if (updateChunkData == null) {
            throw new ApiException("Missing the required parameter 'updateChunkData' when calling updateChunk(Async)");
        }

        return updateChunkCall(trDataset, updateChunkData, _callback);

    }

    /**
     * Update Chunk
     * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkData JSON request payload to update a chunk (chunk) (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content Ok response indicating the chunk was updated as requested </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public void updateChunk(String trDataset, UpdateChunkData updateChunkData) throws ApiException {
        updateChunkWithHttpInfo(trDataset, updateChunkData);
    }

    /**
     * Update Chunk
     * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkData JSON request payload to update a chunk (chunk) (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content Ok response indicating the chunk was updated as requested </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> updateChunkWithHttpInfo( @NotNull String trDataset,  @NotNull UpdateChunkData updateChunkData) throws ApiException {
        okhttp3.Call localVarCall = updateChunkValidateBeforeCall(trDataset, updateChunkData, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update Chunk (asynchronously)
     * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkData JSON request payload to update a chunk (chunk) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content Ok response indicating the chunk was updated as requested </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk, likely due to conflicting tracking_id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateChunkAsync(String trDataset, UpdateChunkData updateChunkData, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateChunkValidateBeforeCall(trDataset, updateChunkData, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateChunkByTrackingId
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk has been updated as per your request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateChunkByTrackingIdCall(String trDataset, UpdateChunkByTrackingIdData updateChunkByTrackingIdData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateChunkByTrackingIdData;

        // create path and map variables
        String localVarPath = "/api/chunk/tracking_id/update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trDataset != null) {
            localVarHeaderParams.put("TR-Dataset", localVarApiClient.parameterToString(trDataset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateChunkByTrackingIdValidateBeforeCall(String trDataset, UpdateChunkByTrackingIdData updateChunkByTrackingIdData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trDataset' is set
        if (trDataset == null) {
            throw new ApiException("Missing the required parameter 'trDataset' when calling updateChunkByTrackingId(Async)");
        }

        // verify the required parameter 'updateChunkByTrackingIdData' is set
        if (updateChunkByTrackingIdData == null) {
            throw new ApiException("Missing the required parameter 'updateChunkByTrackingIdData' when calling updateChunkByTrackingId(Async)");
        }

        return updateChunkByTrackingIdCall(trDataset, updateChunkByTrackingIdData, _callback);

    }

    /**
     * Update Chunk By Tracking Id
     * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks) (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk has been updated as per your request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk </td><td>  -  </td></tr>
     </table>
     */
    public void updateChunkByTrackingId(String trDataset, UpdateChunkByTrackingIdData updateChunkByTrackingIdData) throws ApiException {
        updateChunkByTrackingIdWithHttpInfo(trDataset, updateChunkByTrackingIdData);
    }

    /**
     * Update Chunk By Tracking Id
     * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks) (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk has been updated as per your request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> updateChunkByTrackingIdWithHttpInfo( @NotNull String trDataset,  @NotNull UpdateChunkByTrackingIdData updateChunkByTrackingIdData) throws ApiException {
        okhttp3.Call localVarCall = updateChunkByTrackingIdValidateBeforeCall(trDataset, updateChunkByTrackingIdData, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update Chunk By Tracking Id (asynchronously)
     * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * @param trDataset The dataset id to use for the request (required)
     * @param updateChunkByTrackingIdData JSON request payload to update a chunk by tracking_id (chunks) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Confirmation that the chunk has been updated as per your request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Service error relating to to updating chunk </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateChunkByTrackingIdAsync(String trDataset, UpdateChunkByTrackingIdData updateChunkByTrackingIdData, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateChunkByTrackingIdValidateBeforeCall(trDataset, updateChunkByTrackingIdData, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
